```{r grid-setup, include = FALSE}
knitr::opts_chunk$set(fig.path = "figures/")
library(tidymodels)
library(finetune)
library(ggforce)
library(av)
library(lme4)
data(cells)

library(doMC)
registerDoMC(cores = parallel::detectCores(logical = TRUE))

library(kableExtra)

## -----------------------------------------------------------------------------

load("RData/mlp_times.RData")
```


# Grid search {#grid-search}

In Chapter \@ref(tuning) we demonstrated how users can mark or tag arguments in preprocessing recipes and/or model specifications for optimization using the `tune()` function.  Once we know what to optimize, it's time to address the question of how to optimize the parameters. This chapter describes **grid search** methods that specify the possible values of the parameters _a priori_. (Chapter \@ref(tuning) will continue the discussion by describing iterative search methods.) 

Let's start by describing two main approaches for assembling a grid. 

## Regular and non-regular grids {#grids}

There are two main types of grids. The first is a regular grid where each parameter has a corresponding set of possible values. A regular grid combines these factorially, i.e., by using all combinations of the sets. Alternatively, a non-regular grid is one where the parameter combinations are not formed from a small set of points. 

Before considering each type, let's consider an example model: the  multilayer perceptron model (a.k.a. single layer artificial neural network).  The parameters marked for tuning are: 

* the number of hidden units, 

* the number of fitting epochs/iterations in model training, and  

* the amount of weight decay penalization. 

:::rmdnote
Historically, the number of epochs was determined by early stopping; a separate validation set determined the length of training based on the error rate, since re-predicting the training set led to overfitting. In our case, the use of a weight decay penalty should prohibit overfitting, but there is little harm in tuning the penalty and the number of epochs. 
:::

Using `r pkg(parsnip)`, the specification for a classification model fit using the `r pkg(nnet)` package is: 

```{r grid-mlp}
mlp_spec <- 
 mlp(hidden_units = tune(), penalty = tune(), epochs = tune()) %>% 
 set_engine("nnet", trace = 0) %>% 
 set_mode("classification")
```

The argument `trace = 0` prevents extra logging of the training process. As shown in Section \@ref(tuning-params-tidymodels), the `parameters()` function can extract the set of arguments with unknown values and sets their `r pkg(dials)` objects: 

```{r grid-mlp-param}
mlp_param <- parameters(mlp_spec)
mlp_param %>% pull_dials_object("hidden_units")
mlp_param %>% pull_dials_object("penalty")
mlp_param %>% pull_dials_object("epochs")
```

This output indicates that the parameter objects are complete and prints their default ranges. These values will be used to demonstrate how to create different types of parameter grids. 

### Regular grids {-}

Regular grids are combinations of separate sets of parameter values. First, the user creates a distinct set of values for each parameter.  The number of possible values need not be the same for each parameter. The `r pkg(tidyr)` function `crossing()` is one way to create a regular grid: 

```{r grid-crossing}
crossing(
  hidden_units = 1:3,
  penalty = c(0.0, 0.1),
  epochs = c(100, 200)
)
```

The parameters object knows the ranges of the parameters. The `r pkg(dials)` packages contains a set of `grid_*()` functions that take the parameters object as input to produce different types of grids. For example: 

```{r grid-reg}
grid_regular(mlp_param, levels = 2)
```
The `levels` argument is the number of levels _per parameter_ to create. It can also take a named vector of values: 

```{r grid-reg-lvls}
mlp_param %>% 
  grid_regular(levels = c(hidden_units = 3, penalty = 2, epochs = 2))
```

There are techniques for creating regular grids that do not use all possible values of each parameter set. These _fractional factorial designs_ [@BHH] could also be used. To learn more, consult the CRAN Task View for experimental design^[[https://CRAN.R-project.org/view=ExperimentalDesign](https://CRAN.R-project.org/view=ExperimentalDesign)]. 

:::rmdwarning
Regular grids can be computationally expensive to use, especially when there are a medium to large number of tuning parameters. This is true for many models but not all. As discussed in Section \@ref(efficient-grids) below, there are many models whose tuning time _decreases_ with a regular grid!
:::

One advantage to using a regular grid is that the relationships and patterns between the tuning parameters and the model metrics are easily understood. The factorial nature of these designs allows for examination of each parameter separately with little confounding between parameters.   

### Irregular grids {-}

There a several options for creating non-regular grids. The first is to use random sampling across the range of parameters. `grid_random()` generates independent uniform random numbers across the parameter ranges. If the parameter object has an associated transformation (such as we have for `penalty`), the random numbers are generated on the transformed scale.  For example: 

```{r grid-rand}
set.seed(10)
mlp_param %>% 
  grid_random(size = 1000) %>% # 'size' is the number of combinations
  summary()
```

For `penalty`, the random numbers are uniform on the log (base 10) scale but the values in the grid are in the natural units. 

The issue with random grids is that, with small-to-medium grids, random values can result in overlapping parameter combinations. Also, the random grid needs to cover the whole parameter space but the likelihood of good coverage increases with the number of grid values.  Even for a sample of 15 candidate points, this plot shows some overlap between points for our example multilayer perceptron: 

```{r grid-random-matrix, fig.height = 6, fig.width = 6}
library(ggforce)
set.seed(200)
mlp_param %>% 
  # The 'original = FALSE' option keeps penalty in log10 units
  grid_random(size = 15, original = FALSE) %>% 
  ggplot(aes(x = .panel_x, y = .panel_y)) + 
  geom_point() +
  geom_blank() +
  facet_matrix(vars(hidden_units, penalty, epochs), layer.diag = 2) + 
  labs(title = "Random design with 15 candidates")
```

A much better approach is to use a set of experimental designs called _space-filling designs_. While different design methods have slightly different goals, they generally find a configuration of points that cover the parameter space with the smallest chance of overlapping or redundant values. Examples of such designs are Latin hypercubes [@lhd], maximum entropy designs [@maxent], maximum projection designs [@maxproj], and others. See @santner2003design for an overview. 

The `r pkg(dials)` package contains functions for Latin hypercube and maximum entropy designs. As with `grid_random()`, the primary inputs are the number of parameter combinations and a parameters object. Let's compare a random design with a Latin hypercube design for 15 candidate parameter values. 

```{r grid-sfd-compare, fig.height = 6, fig.width = 6}
set.seed(200)
mlp_param %>% 
  grid_latin_hypercube(size = 15, original = FALSE) %>% 
  ggplot(aes(x = .panel_x, y = .panel_y)) + 
  geom_point() +
  geom_blank() +
  facet_matrix(vars(hidden_units, penalty, epochs), layer.diag = 2) + 
  labs(title = "Latin Hypercube design with 15 candidates")
```

While not perfect, this design spaces the points further away from one another.  

Space-filling designs can be very effective at representing the parameter space. The default design used by the `r pkg(tune)` package is the maximum entropy design. These tend to produce grids that cover the candidate space well and drastically increase the chances of finding good results. 

## Evaluating the grid

To choose the best tuning parameter combination, each candidate set is assessed using data that were not used to train the model. Resampling methods or a simple validation set work well for this purpose. The process (and syntax) closely resembles the approach in Section \@ref(resampling-performance) that used the `fit_resamples()` function from the `r pkg(tune)` package. 

After resampling, the user selects the most appropriate candidate parameter set. It might make sense to choose the empirically best parameter combination or bias the choice towards other aspects of the model fit, such as simplicity. 


A classification data set is used to demonstrate model tuning in this and the next chapter. The data come from @Hill, who developed am automated microscopy laboratory tool used for cancer research. The data consists of 56 imaging measurements on 2019 human breast cancer cells. These predictors represent shape and intensity characteristics of different parts of the cells (e.g., the nucleus, the cell boundary, etc.). There is a high degree of correlation between the predictors. For example, there are several different predictors that measure the size and shape of the nucleus and cell boundary. Also, individually, many predictors have skewed distributions.

Each cell belongs to one of two classes. Since this is part of an automated lab test, the focus was on prediction capability and not inference. 

The data are included in the `r pkg(modeldata)` package. One column not needed for analysis (`case`) is removed. 

```{r grid-cells}
library(tidymodels)
data(cells)
cells <- cells %>% select(-case)
```

Given the dimensions of the data, performance metrics are computed using simple 10-fold cross-validation. 

```{r grid-cells-folds}
set.seed(33)
cell_folds <- vfold_cv(cells)
```

Given the high degree of correlation between predictors, it may be sensible to use PCA feature extraction to decorrelate the predictors. The following recipe contains steps to transform the predictors to increase symmetry, normalize them to be on the same scale, then conduct feature extraction. The number of PCA components to retain is also tuned. While the resulting PCA components are technically on the same scale, the earlier components tend to have a wider range than the later components. For this reason, a final normalization will coerce the predictors to have the same mean and variance.

As previously mentioned, many of the predictors have skewed distributions. Since PCA is variance based, extreme values can have a detrimental effect on these calculations. To counter this, a recipe step estimates a Yeo-Johnson transformation for each predictor [@yeo2000new]. While originally intended as a transformation of the _outcome_, it can also me used to estimate transformations that encourage more symmetric distributions.  This step occurs in the recipe just prior to the initial normalization.

```{r grid-cells-objects}
mlp_rec <-
  recipe(class ~ ., data = cells) %>%
  step_YeoJohnson(all_predictors()) %>% 
  step_normalize(all_predictors()) %>% 
  step_pca(all_predictors(), num_comp = tune()) %>% 
  step_normalize(all_predictors())

mlp_wflow <- 
  workflow() %>% 
  add_model(mlp_spec) %>% 
  add_recipe(mlp_rec)
```

Let's create a parameter object to adjust a few of the default ranges. The number of epochs will have a smaller range (50 to 200 epochs). Also, the default range for `num_comp()`  defaults to a very narrow range (one to four components); we can increase the range up to 40 components and set the minimum value to zero. 

:::rmdnote
In `step_pca()`, using zero PCA components is a shortcut to _skip_ the feature extraction. In this way, the original predictors can be directly compared to the results that include PCA components. 
:::


```{r grid-cells-workflow}
mlp_param <- 
  mlp_wflow %>% 
  parameters() %>% 
  update(
    epochs = epochs(c(50, 200)),
    num_comp = num_comp(c(0, 40))
  )
```

The `tune_grid()` function is the primary function for conducting grid search. Its functionality is very similar to `fit_resamples()` from Section \@ref(resampling-performance), although it has additional arguments related to the grid: 

* `grid`: An integer or data frame. When an integer is used, the function creates a space filling design with `grid` number of candidate parameters combinations. If specific parameter combinations exist, the `grid` parameter is used to pass them to the function. 

* `param_info`: An _optional_ argument for defining the parameter ranges. The is most useful when `grid` is an integer. 

Otherwise, the interface to `tune_grid()` is the same as `fit_resamples()`. The first argument is either a model specification or workflow. When a model is given, the second argument can be either a recipe or formula. The other required argument is an `r pkg(rsample)` resampling object (such as `cell_folds`). The call below also passes a metric set so that the area under the ROC curve is measured during resampling. 

To start, a regular grid with three levels is evaluated across the resamples: 

```{r grid-cells-regular, cache = TRUE}
roc_res <- metric_set(roc_auc)
set.seed(99)
mlp_reg_tune <-
  mlp_wflow %>%
  tune_grid(
    cell_folds,
    grid = mlp_param %>% grid_regular(levels = 3),
    metrics = roc_res
  )
mlp_reg_tune
```

There are high-level convenience functions to understand the results. First, the `autoplot()` method for regular grids shows the performance profiles across tuning parameters:  

```{r grid-cells-reg-plot, fig.height = 6}
autoplot(mlp_reg_tune)
```

For these data, the amount of penalization has the largest impact on the area under the ROC curve. The number of epochs doesn't appear to have a pronounced effect on performance. The change in the number of hidden units appears to matter most when the amount of regularization is low (with reduced performance). There are several parameter configurations that have roughly equivalent performance, as seen using the function `show_best()`: 

```{r grid-cells-reg-best}
show_best(mlp_reg_tune) %>% select(-.estimator)
```

Based on these results, it would make sense to conduct another run of grid search with larger values of the weight decay penalty. 

To use a space-filling design, the `grid` argument can be given an integer or one of the `grid_*()` functions can produce a data frame. To evaluate the same range using a maximum entropy design with 20 candidate values: 

```{r grid-cells-sdf, cache = TRUE}
set.seed(99)
mlp_sfd_tune <-
  mlp_wflow %>%
  tune_grid(
    cell_folds,
    grid = 20,
    # Pass in the parameter object to use the appropriate range: 
    param_info = mlp_param,
    metrics = roc_res
  )
mlp_sfd_tune
```

The `autoplot()` method will also work with these designs although the format of the results are different:

```{r grid-cells-sdf-plot}
autoplot(mlp_sfd_tune)
```

This _marginal effects plot_ shows the relationship of each parameter with the performance metric. 

:::rmdwarning
Care should be taken when examining this plot; since a regular grid is not used, the values of the other tuning parameters can affect each panel. 
:::

For example, the penalty parameter appears to have better performance with smaller amounts of weight decay. This is the opposite of the results from the regular grid. Since each point in each panel is shared with the other three tuning parameters, the trends in one panel can be affected by the others. Using a regular grid, each point in each panel is equally averaged over the other parameters. For this reason, the affect of each parameter is better isolated with regular grids.  

As with the regular grid, `show_best()` can report on the numerically best results: 

```{r grid-cells-sdf-best}
show_best(mlp_sfd_tune) %>% select(-.estimator)
```

Generally, it is a good idea to evaluate the models over multiple metrics so that different aspects of the model fit are taken into account. Also, it often makes sense to choose a slightly sub-optimal parameter combination that is associated with a simpler model. For this model, simplicity corresponds to larger penalty values and/or fewer hidden units.  

As with the results from `fit_resamples()`, there is usually no value in retaining the intermediary model fits across the resamples and tuning parameters. However, as before, the `extract` option to `control_grid()` allows the retention of the fitted models and/or recipes. Also, setting the `save_pred` option to `TRUE` retains the assessment set predictions and these are easily accessed using `collect_predictions()`. 

## Finalizing the model

If this model were an attractive one for these data, we might wish to evaluate how well it does on the test set. However, the results of `tune_grid()` only provide the substrate to choose appropriate tuning parameter. The function does not fit a final model. 

To do this, a set of parameter values must be determined. There are two methods to do so: manually picking values that appear appropriate or to use a `select_*()` function. For example, `select_best()` will choose the parameters with the numerically best results:

```{r grid-select}
select_best(mlp_reg_tune, metric = "roc_auc")
```

Looking at the results for the regular grid plot, a model with a single hidden unit trained for 125 epochs on the original predictors with a large amount of penalization has competitive performance. It is basically penalized logistic regression. To manually specific these parameters, we can create a tibble with these values and then use a _finalization_ function to splice the values back into the workflow: 

```{r grid-finalize-manual}
logistic_param <- 
  tibble(
    num_comp = 0,
    epochs = 125,
    hidden_units = 1,
    penalty = 1
  )

final_mlp_wflow <- 
  mlp_wflow %>% 
  finalize_workflow(logistic_param)
final_mlp_wflow
```
No residual values of `tune()` are included in the workflow. Now the model is fit to the _entire training set_: 

```{r grid-final-model}
final_mlp_fit <- 
  final_mlp_wflow %>% 
  fit(cells)
```

This object is used to make future predictions. 

If a workflow was not used, finalization of a model and/or recipe is done using `finalize_model()` and `finalize_recipe()`. 


## Tools for efficient grid search {#efficient-grids}

A few different tricks and optimization are possible to make grid search more computationally efficient. This section describes several techniques. 

### Submodel optimization {-}

There are types of models where, from a single model fit, multiple tuning parameters can be evaluated without refitting. 

For example, partial least squares (PLS) is a supervised version of principal component analysis [@Geladi:1986]. It creates components that maximize the variation in the predictors (like PCA) but simultaneously tries to maximize the correlation between these predictors and the outcome. One tuning parameter is the number of PLS components to retain. Suppose that a data set with 100 predictors is fit using PLS. The number of possible components to retain can range from one to fifty. However, in many implementations, a single model fit can compute predicted values across many values of `num_comp`. As a result, a PLS model created with 100 components can also make predictions for any `num_comp <= 100`. The saves time since, instead of creating redundant model fits, a single fit can be used to evaluate many _submodels_.

While not all models can exploit this feature, many broadly used ones do: 

* Boosting models can typically make predictions across multiple values for the number of boosting iterations. 

* Regularization methods, such as the `r pkg(glmnet)` model, can make simultaneous predictions across the amount of regularization used to fit the model. 

* Multivariate adaptive regression splines (MARS) adds a set of nonlinear features features to a linear regression models [@Friedman:1991p109]. The number of terms to retain is a tuning parameter and it is computationally fast to make predictions across many values of this parameter from a single model fit. 

The `r pkg(tune)` package automatically applies this type of optimization whenever an applicable model is tuned. 

For example, if a boosted C5.0 classification model [@apm] was fit to the cell data, we can tune the number of boosting iterations (`trees`). With all other parameters set at their default values, we can evaluate iterations from 1 to 100 on the same resamples as used previously:

```{r grid-c5, eval = FALSE}
c5_spec <- 
  boost_tree(trees = tune()) %>% 
  set_engine("C5.0") %>% 
  set_mode("classification")

set.seed(2)
c5_spec %>%
  tune_grid(
    class ~ .,
    resamples = cell_folds,
    grid = data.frame(trees = 1:100),
    metrics = roc_res
  )
```

Without the submodel optimization, the call to `tune_grid()` used `r round(3734.249/60, 1)` minutes to resample 100 submodels. With the optimization, the same call took 100 _seconds_ (a speedup of `r round(3734.249/100.147, 0)`-fold). The reduced time is the difference in `tune_grid()` fitting 1000 models versus 10 models. 

:::rmdnote
Even though we fit the model with and without the submodel prediction trick, this optimization is _automatically_ applied by `r pkg(parsnip)`. 
:::

### Parallel processing {-}

As previously mentioned in Section \@ref(parallel), parallel processing is an effective method for decreasing execution time when models are resampled. This advantage conveys to model tuning via grid search, although there are additional considerations. 

When tuning models via grid search, the process involves two distinct loops: one over resamples and another over the unique tuning parameter combinations. This process can be represented but pseudocode: 

```{r grid-resamples-algo, attr.source = '.numberLines', eval = FALSE}
for (rs in resamples) {
   # Create analysis and assessment sets
   # Preprocess data (e.g. formula or recipe)
   for (mod in configurations) {
      # Fit model {mod} to the {rs} analysis set
      # Predict the {rs} assessment set
   }
}
```

By default, the `r pkg(tune)` package only parallelizes over resamples (line 1 above), as opposed the two loops at lines 1 _and_ 4.

This is the optimal scenario when the preprocessing method is expensive. However, there are two potential downsides to this approach: 

* It limits the achievable speed-ups when the preprocessing is not expensive, and

* The number of parallel workers is limited by the number of resamples. For example, with 10-fold cross-validation you can only use 10 parallel workers even when the computer has more than 10 cores. 

Alternatively, these two nested loops can be _flattened_ or combined into a single loop, represented in this pseudocode: 

```{r grid-everything-algo, attr.source = '.numberLines', eval = FALSE}
all_tasks <- crossing(resamples, configurations)

for (iter in all_tasks) {                           
   # Create analysis and assessment sets for {iter}
   # Preprocess data (e.g. formula or recipe)
   # Fit model {iter} to the {iter} analysis set
   # Predict the {iter} assessment set
}
```

In this case, parallelization now occurs at line 3. For example, if 10-fold cross-validation is used with $M$ tuning parameter values, the loop is executed over $10M$ iterations. This increases the number of potential workers that can be put to use. However, lines 4-5 (related to data processing) are _repeated_ $M-1$ additional times. If those steps are expensive, this will be more inefficient than the previous approach. 

In the control functions for the `tune_*()` functions, the argument `parallel_over` controls how the process is executed. A value of `parallel_over = "resamples"` takes the first approach described above while `parallel_over = "everything"` parallelizes over the "flattened loop". 

As a superficial benchmark, the multilayer perceptron `tune_grid()` code from Section \@ref(grids) was re-run with different numbers of parallel workers using a computer with 10 physical cores. The results show that parallel process effectively reduces the total execution time for this model: 

```{r grid-parallel, echo = FALSE, results = "asis"}
options(knitr.kable.NA = '')
times %>% 
  mutate(speed_up = ifelse(cores == 1, NA, speed_up)) %>% 
  arrange(`Grid Type`, cores) %>% 
  select(
    `# Workers` = cores,
    `Time (s)` = time,
    `Time/Fit (s)` = time_per_fit,
    `Speed-Up` = speed_up
  ) %>%
  kable(
    row.names = FALSE, 
    digits = 2
  ) %>% 
  kable_paper("striped", full_width = FALSE) %>%
  pack_rows("Regular Grid", 1, 3) %>%
  pack_rows("Space-Filling Design", 4 , 6)
```

As another example, the C5.0 classification model shown in the previous section was also run in parallel with ten workers. The parallel computations took 13.3 seconds for a speed-up of `r round(100.147/13.265, 1)`-fold (both runs used the submodel optimization trick). Between the submodel optimization trick and parallel processing, there was a __total speed-up of `r round(3734.249/13.265, 0)`-fold__ over the most basic grid search code. 

Note that the speed-up in computations will vary from model to model and is also affected by the size of the grid. A very computationally efficient model may not benefit as much from parallel processing. 

### Racing methods {-}

One issue with grid search is that all models need to be fit across all resamples before any tuning parameters can be evaluated. It would be helpful if, at some point during tuning, an interim analysis can be conducted to eliminate any truly awful parameter candidates. This would be akin to _futility analysis_ in clinical trials. If a new drug is performing excessively poorly (or well), it is potentially unethical to wait until the trial finishes to make a decision.  

In machine learning, the set of techniques called _racing methods_ provide a similar function [@maron1994hoeffding]. Here, the tuning process evaluates all models on an initial subset of resamples. Based on their current performance metrics, some parameter sets are not considered in subsequent resamples. 

```{r grid-cells-race, cache = TRUE, include = FALSE}
set.seed(99)
mlp_sfd_race <-
  mlp_wflow %>%
  tune_race_anova(
    cell_folds,
    grid = 20,
    # Pass in the parameter object to use the appropriate range: 
    param_info = mlp_param,
    metrics = roc_res
  )
remaining <-
  mlp_sfd_race %>% 
  collect_metrics() %>% 
  dplyr::filter(n == 10)
```


As an example, in the previous multilayer perceptron tuning process with a regular grid, what would the results look after the first three folds? Using techniques similar to those shown in Chapter \@ref(compare), a model is fit where the outcome is the resampled area under the ROC curve and the predictor is an indicator for the parameter combination. The model takes the resample-to-resample effect into account and produces point and interval estimates for each parameter settings. The results of the model are one-sided 95% confidence intervals that measure the loss of the ROC value relative to the currently best performing parameters: 

```{r grid-mlp-racing, echo = FALSE, fig.height=5, warning = FALSE}
full_att <- attributes(mlp_sfd_race)

race_details <- NULL
for(iter in 1:10) {

  tmp <- mlp_sfd_race %>% filter(.order <= iter)
  tmp_att <- full_att
  tmp_att$row.names <- attr(tmp, "row.names")
  attributes(tmp) <- tmp_att

  race_details <-
    bind_rows(
      race_details,
      finetune:::test_parameters_gls(tmp) %>% mutate(iter = iter))
}

race_details <-
  race_details %>%
  mutate(
    lower = ifelse(iter < 3, NA, lower),
    upper = ifelse(iter < 3, NA, upper),
    pass = ifelse(iter < 3, TRUE, pass),
    decision = ifelse(pass, "retain", "discard"),
    decision = ifelse(pass & estimate == 0, "best", decision)
  )  %>%
  mutate(
    .config = factor(.config),
    .config = reorder(.config, estimate),
    decision = factor(decision, levels = c("best", "retain", "discard"))
  ) 
race_cols <- c(best = "blue", retain = "black", discard = "grey")

iter_three <- race_details %>% dplyr::filter(iter == 3) 

iter_three %>% 
  ggplot(aes(x = -estimate, y = .config)) + 
  geom_vline(xintercept = 0, lty = 2, col = "green") +
  geom_point(size = 3, aes(col = decision)) + 
  geom_errorbarh(aes(xmin = -estimate, xmax = -upper, col = decision), height = .3, show.legend = FALSE) + 
  labs(x = "Loss of ROC AUC", y = NULL) + 
  scale_colour_manual(values = race_cols)
```

Any parameter set whose confidence interval includes zero would lack evidence that its performance is not statistically different from the best results. We retain `r sum(iter_three$upper < 0)` settings; these are resampled more. The remaining `r sum(iter_three$upper >= 0)` submodels are no longer considered. 

```{r grid-mlp-racing-anim, include = FALSE, dev = 'png'}
race_ci_plots <- function(x, iters = 10) {
  
  x_rng <- extendrange(c(-x$estimate, -x$upper))
  
  for (i in 1:iters) {
    if (i < 3) {
      ttl <- paste0("Iteration ", i, ": burn-in")
    } else {
      ttl <- paste0("Iteration ", i, ": testing")
    }
    p <-
      x %>% 
      dplyr::filter(iter == i) %>% 
      ggplot(aes(x = -estimate, y = .config, col = decision)) +
      geom_vline(xintercept = 0, col = "green", lty = 2) +
      geom_point(size = 2) +
      labs(title = ttl, y = "", x = "Loss of ROC AUC") +
      scale_color_manual(values = c(best = "blue", retain = "black", discard = "grey"), 
                         drop = FALSE) +
      scale_y_discrete(drop = FALSE) +
      xlim(x_rng) + 
      theme_bw() +
      theme(legend.position = "top")
    
    if (i >= 3) {
      p <- p  + geom_errorbar(aes(xmin = -estimate, xmax = -upper), width = .3)
    }
    
    print(p)
  }
  invisible(NULL)
}
av_capture_graphics(
  race_ci_plots(race_details, 10),
  output = "_book/premade/race_results.mp4",
  width = 720,
  height = 720,
  res = 120,
  framerate = 1/3
)
```

<video width="720" height="720" controls>
  <source src="_book/premade/race_results.mp4" type="video/mp4">
</video>

The process continues for each resample; after the next set of performance metrics, a new model is fit to these statistics, and more  submodels are potentially discarded. See @kuhn2014futility for more details on the computational aspects of this approach. 

:::rmdwarning
Racing methods can be more efficient than basic grid search as long as the interim analysis is fast and some parameter settings have poor performance. It also is most helpful when the model does _not_ have the ability to exploit submodel predictions. 
:::

The `r pkg(finetune)` package contains functions for racing. The `tune_race_anova()` function conducts an Analysis of Variance (ANOVA) model to tests for statistical significance of the different model configurations. The syntax to reproduce the filtering shown above is


```{r grid-cells-race-code, eval = FALSE}
library(finetune)

set.seed(99)
mlp_sfd_race <-
  mlp_wflow %>%
  tune_race_anova(
    cell_folds,
    grid = 20,
    param_info = mlp_param,
    metrics = roc_res
  )
```

The arguments mirror those of `tune_grid()`. The function `control_race()` has options for the elimination procedure. 

As shown in the animation above, there were `r nrow(remaining)` tuning parameter combinations under consideration once the full set of resamples were evaluated. `show_best()` returns the best models (ranked by performance) but only returns the configurations that were never eliminated: 

```{r grid-race-best}
 show_best(mlp_sfd_race, n = 10)
```


There are other interim analysis techniques for discarding settings. For example, @krueger15a uses traditional sequential analysis methods whereas @kuhn2014futility treats the data as a sports competition and uses the Bradley-Terry model [@bradley1952rank] to measure the winning ability of parameter settings. 


## Chapter summary {#grid-summary}

This chapter discussed the two main classes of grids (regular and non-regular) that can be used for model tuning and demonstrated how to construct these grids, either manually or using the family of `grid_*()` functions. The `tune_grid()` function can evaluate these candidate sets of model parameters using resampling. The chapter also showed how to update a model, recipe, or workflow to update the parameter values for the final fit. 

The data analysis code that will be reused in the next chapter is:  

```{r resampling-summary, eval = FALSE}
library(tidymodels)

data(cells)
cells <- cells %>% select(-case)

set.seed(33)
cell_folds <- vfold_cv(cells)

roc_res <- metric_set(roc_auc)
```
