<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>1 A review of base R modeling syntax | base-r.utf8</title>
  <meta name="description" content="" />
  <meta name="generator" content="bookdown 0.17 and GitBook 2.6.7" />

  <meta property="og:title" content="1 A review of base R modeling syntax | base-r.utf8" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="1 A review of base R modeling syntax | base-r.utf8" />
  
  
  




  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  


<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />











<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><strong><a href="./">Tidy Modeling with R</a></strong></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path=""><a href="#base-r"><i class="fa fa-check"></i><b>1</b> A review of base R modeling syntax</a><ul>
<li class="chapter" data-level="1.1" data-path=""><a href="#an-example"><i class="fa fa-check"></i><b>1.1</b> An example</a></li>
<li class="chapter" data-level="1.2" data-path=""><a href="#why-tidiness-is-important-for-modeling"><i class="fa fa-check"></i><b>1.2</b> Why tidiness is important for modeling</a></li>
<li class="chapter" data-level="1.3" data-path=""><a href="#some-additional-tidy-principals-for-modeling."><i class="fa fa-check"></i><b>1.3</b> Some additional tidy principals for modeling.</a><ul>
<li class="chapter" data-level="1.3.1" data-path=""><a href="#be-predictable-consistent-and-unsurprising"><i class="fa fa-check"></i><b>1.3.1</b> Be predictable, consistent, and unsurprising</a></li>
<li class="chapter" data-level="1.3.2" data-path=""><a href="#encourage-empirical-validation-and-good-methodology."><i class="fa fa-check"></i><b>1.3.2</b> Encourage empirical validation and good methodology.</a></li>
</ul></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./"></a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:title:end-->
<!--bookdown:title:start-->
<div id="base-r" class="section level1">
<h1><span class="header-section-number">1</span> A review of base R modeling syntax</h1>
<p>This book is about software, specifically R syntax for creating models. Before describing how tidy principles can be used in data analysis, it makes sense to show how models are created and utilized using traditional base R code. This section is a brief illustration of the those conventions. It is not exhaustive but provides readers uninitiated to R ideas about the basic motifs that are commonly used.</p>
<p>The S language, on which R is based, has had a rich data analysis environment since the publication of <span class="citation">@WhiteBook</span> (commonly known as The White Book). This version of S introduced standard infrastructure components, such as symbolic model formulae, model matrices, data frames, as well as the standard object-oriented programming methods for data analysis. These user-interfaces have not substantively changes since then.</p>
<div id="an-example" class="section level2">
<h2><span class="header-section-number">1.1</span> An example</h2>
<p>To demonstrate the fundamentals, experimental data from <span class="citation">@mcdonald2009</span> (by way of <span class="citation">@mangiafico2015</span>) are used. These data relate the ambient temperature to the rate of cricket chirps per minute. Data were collected for two species: <em>O. exclamationis</em> and <em>O. niveus</em>. The data are contained in a data frame called <code>crickets</code> that contains a total of 31 data points. These data are shown via a <code>ggplot</code> graph.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">names</span>(crickets)</a></code></pre></div>
<pre><code>## [1] &quot;species&quot; &quot;temp&quot;    &quot;rate&quot;</code></pre>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co"># Plot the temperature on the x-axis, the chirp rate on the y-axis. The plot</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="co"># elements will be colored differently for each species:</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">ggplot</span>(crickets, <span class="kw">aes</span>(<span class="dt">x =</span> temp, <span class="dt">y =</span> rate, <span class="dt">col =</span> species)) <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="st">  </span><span class="co"># Plot points for each data point and color by species</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="st">  </span><span class="co"># Show a simple linear model fit created separately for each species:</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">method =</span> lm, <span class="dt">se =</span> <span class="ot">FALSE</span>) <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="st">  </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="st">&quot;Temperature (C)&quot;</span>, <span class="dt">y =</span> <span class="st">&quot;Chirp Rate (per minute)&quot;</span>)</a></code></pre></div>
<p><img src="figures/base-r-cricket-plot-1.svg" width="70%" /></p>
<p>The data show fairly linear trends for each species. For a given temperature, <em>O. exclamationis</em> appears to have more chirps than the other species. For an inferential model, the researchers might have specified the following null hypotheses prior to seeing the data:</p>
<ul>
<li><p>Temperature has no affect on the chirp rate.</p></li>
<li><p>There are no differences between the species in terms of chirp rate.</p></li>
</ul>
<p>There may be some scientific rationale for being able to predict the chirp rate but the focus here will be on inference.</p>
<p>To fit an ordinary linear model, the <code>lm()</code> function is commonly used. The important arguments to this function are a model formula and a data frame that contains the data The formula is <em>symbolic</em>. For example, the simple formula:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" data-line-number="1">rate <span class="op">~</span><span class="st"> </span>temp</a></code></pre></div>
<p>states that the chirp rate is the outcome (since it is on the left-hand side of the tilde <code>~</code>) and that the temperature values are the predictor<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>. Suppose the data contained the time of day in which the measurements were obtained in a column called <code>time</code>. The formula</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" data-line-number="1">rate <span class="op">~</span><span class="st"> </span>temp <span class="op">+</span><span class="st"> </span>time</a></code></pre></div>
<p>would not add the time and temperature values together. This formula would symbolically represent that temperature and time should be added as a separate <em>main effects</em> to the model. Main effects are model terms that contain a single predictor variable.</p>
<p>There are no time measurements in these data but the species can be added to the model in the same way:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" data-line-number="1">rate <span class="op">~</span><span class="st"> </span>temp <span class="op">+</span><span class="st"> </span>species</a></code></pre></div>
<p>Species is not a quantitative variable; in the data frame, it is represented as a factor column with levels <code>&quot;O. exclamationis&quot;</code> and <code>&quot;O. niveus&quot;</code>. The vast majority of model functions cannot operate on non-numeric data. For species, the model needs to <em>encode</em> the species data into a numeric format. The most common approach is to use indicator variables (also known as “dummy variables”) in place of the original qualitative values. In this instance, since species has two possible values, the model formula will automatically encode this column as numeric by adding a new column that has a value of zero when the species is <code>&quot;O. exclamationis&quot;</code> and a value of one when the data correspond to <code>&quot;O. niveus&quot;</code>. The underlying formula machinery will automatically convert these values for the data set used to create the model as well as for any new data points (for example, when the model is used for prediction).</p>
<p>Suppose there were five species. The model formula would automatically add <em>four</em> additional binary columns that are binary indicators for four of the species. The <em>reference level</em> of the factor (i.e., the first level) is always left out of the predictor set. The idea is that, if you know the values of the four indicator variables, the value of the species can be determined.</p>
<p>The model formula shown above creates a model where there are different y-intercepts for each species. It is a reasonable supposition that the slopes of the regression lines could be different for each species. To accommodate this structure, an <em>interaction</em> term can be added to the model. This can be specified in a few different ways, the most basic uses the colon:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" data-line-number="1">rate <span class="op">~</span><span class="st"> </span>temp <span class="op">+</span><span class="st"> </span>species <span class="op">+</span><span class="st"> </span>temp<span class="op">:</span>species</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="co"># A shortcut can be used to expand all interactions containing</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="co"># interactions with two variables:</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">rate <span class="op">~</span><span class="st"> </span>(temp <span class="op">+</span><span class="st"> </span>species)<span class="op">^</span><span class="dv">2</span></a></code></pre></div>
<p>In addition to the convenience of automatically creating indicator variables, the formula offers a few other niceties:</p>
<ul>
<li><p><em>In-line</em> functions can be used in the formula. For example, if the natural log of the temperate were used, the formula <code>rate ~ log(temp)</code> could be used. Since the formula is symbolic by default, literal math can also be done to the predictors using the identity function <code>I()</code>. For example, to use Fahrenheit units, the formula could be <code>rate ~ I( (temp * 9/5) + 32 )</code> to make the conversion.</p></li>
<li><p>R has many functions that are useful inside of formulas. For example, <code>poly(x, 3)</code> would create linear, quadratic, and cubic terms for <code>x</code> to the model as main effects. Also, the <code>splines</code> package has several functions to create nonlinear spline terms in the formula.</p></li>
<li><p>For data sets where there are many predictors, the period shortcut is available. The period represents main effects for all of the columns that are not on the left-hand side of the tilde. For example, using <code>~ (.)^3</code> would create main effects as well as all two- and three-variable interactions to the model.</p></li>
</ul>
<p>For the initial data analysis, the two-factor interaction model is used. In this book, the suffix <code>_fit</code> is used for R objects that are fitted models.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" data-line-number="1">interaction_fit &lt;-<span class="st">  </span><span class="kw">lm</span>(rate <span class="op">~</span><span class="st"> </span>(temp <span class="op">+</span><span class="st"> </span>species)<span class="op">^</span><span class="dv">2</span>, <span class="dt">data =</span> crickets) </a>
<a class="sourceLine" id="cb8-2" data-line-number="2"></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="co"># To print a short summary of the model:</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">interaction_fit</a></code></pre></div>
<pre><code>## 
## Call:
## lm(formula = rate ~ (temp + species)^2, data = crickets)
## 
## Coefficients:
##           (Intercept)                   temp       speciesO. niveus  
##               -11.041                  3.751                 -4.348  
## temp:speciesO. niveus  
##                -0.234</code></pre>
<p>This output is a little hard to read. For the species indicator variables, R mashes the variable name (<code>species</code>) together with the factor level (<code>O. niveus</code>) with no delimiter.</p>
<p>Before going into any inferential results for this model, the fit should be assessed using diagnostic plots. The <code>plot()</code> method for <code>lm</code> objects can be used. It produces a set of four plots for the object, each showing different aspects of the fit. Two plots are shown here:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="co"># Place two plots next to one another:</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>))</a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="co"># Show residuals vs predicted values:</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="kw">plot</span>(interaction_fit, <span class="dt">which =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="co"># A normal quantile plot on the residuals:</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8"><span class="kw">plot</span>(interaction_fit, <span class="dt">which =</span> <span class="dv">2</span>)</a></code></pre></div>
<p><img src="figures/interaction-plots-1.svg" width="100%" /></p>
<p>These appear reasonable enough to conduct inferential analysis.</p>
<p>From a technical standpoint, R is <em>lazy</em>. Model fitting functions typically compute the minimum possible quantities. For example, there may be interest in the coefficient table for each model term. This is not automatically computed but is instead computed via the <code>summary()</code> method.</p>
<p>Our second order of business is to assess if the inclusion of the interaction term is necessary. The most appropriate approach for this model is to re-compute the model without the interaction term and use the <code>anova()</code> method.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="co"># Fit a reduced model:</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">main_effect_fit &lt;-<span class="st">  </span><span class="kw">lm</span>(rate <span class="op">~</span><span class="st"> </span>temp <span class="op">+</span><span class="st"> </span>species, <span class="dt">data =</span> crickets) </a>
<a class="sourceLine" id="cb11-3" data-line-number="3"></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="co"># Compare the two:</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5"><span class="kw">anova</span>(main_effect_fit, interaction_fit)</a></code></pre></div>
<pre><code>## Analysis of Variance Table
## 
## Model 1: rate ~ temp + species
## Model 2: rate ~ (temp + species)^2
##   Res.Df    RSS Df Sum of Sq     F Pr(&gt;F)
## 1     28 89.350                          
## 2     27 85.074  1    4.2758 1.357 0.2542</code></pre>
<p>The results of the statistical test generates a p-value of 0.25425. This value implies that there is a lack of evidence for the alternative hypothesis that the the interaction term is needed by the model. For this reason, further analysis will be conducted on the model without the interaction.</p>
<p>Residual plots should be re-assessed to make sure that our theoretical assumptions are valid enough to trust the p-values produced by the model (not shown but spoiler alert: they are).</p>
<p>The <code>summary()</code> method is used to inspect the coefficients, standard errors, and p-values of each model term:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">summary</span>(main_effect_fit)</a></code></pre></div>
<pre><code>## 
## Call:
## lm(formula = rate ~ temp + species, data = crickets)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -3.0128 -1.1296 -0.3912  0.9650  3.7800 
## 
## Coefficients:
##                   Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)       -7.21091    2.55094  -2.827  0.00858 ** 
## temp               3.60275    0.09729  37.032  &lt; 2e-16 ***
## speciesO. niveus -10.06529    0.73526 -13.689 6.27e-14 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 1.786 on 28 degrees of freedom
## Multiple R-squared:  0.9896, Adjusted R-squared:  0.9888 
## F-statistic:  1331 on 2 and 28 DF,  p-value: &lt; 2.2e-16</code></pre>
<p>From these values, the chirp rate for each species increases by 3.6 chirps as the temperature increases by a single degree. This term shows strong statistical significance as evidenced by the p-value. The species term has a value of -10.07. This indicates that, across all temperature values, <em>O. niveus</em> is a chirp rate that is about 10 fewer chirps per minute that <em>O. exclamationis</em>. Similar to the temperature term, the species effect is associated with a very small p-value.</p>
<p>The only issue in this analysis is the intercept value. It indicates that at 0 C, there are negative chirps per minute for both species. While this is unreasonable, the data only go as low as 17.2 C and interpreting the model at 0 C would be an <em>extrapolation</em>. This would be a bad idea. That said, the model fit is good within the <em>applicable range</em> of the temperature values and the conclusions should be limited to the observed temperature range.</p>
<p>If there were a need to estimate the chirp rate at a temperature that was not observed in the experiment, the <code>predict()</code> method would be used. It takes the model object and a data frame of new values for prediction. For example, the model estimates the chirp rate for <em>O. exclamationis</em> for temperatures between 15 C and 20 C can be computed via:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb15-1" data-line-number="1">new_values &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">species =</span> <span class="st">&quot;O. exclamationis&quot;</span>, <span class="dt">temp =</span> <span class="dv">15</span><span class="op">:</span><span class="dv">20</span>)</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="kw">predict</span>(main_effect_fit, new_values)</a></code></pre></div>
<pre><code>##        1        2        3        4        5        6 
## 46.83039 50.43314 54.03589 57.63865 61.24140 64.84415</code></pre>
<p>Note that the non-numeric value of <code>species</code> is given to the predict method (as opposed to the binary indicator variable).</p>
<p>While this analysis has obviously not been an exhaustive demonstration of R’s modeling capabilities, it does highlight some of the major features:</p>
<ul>
<li><p>The language has an expressive syntax for specifying model terms for simple and fairly complex models.</p></li>
<li><p>For formula method has many conveniences for modeling that are also applied to new data when predictions are generated.</p></li>
<li><p>There are numerous helper functions (e.g., <code>anova()</code>, <code>summary()</code> and <code>predict()</code>) that are used to conduct specific calculations after the fitted model is created.</p></li>
</ul>
<p>Finally, as previously mentioned, this framework was devised in 1992. Most of the ideas and methods above were developed in that period and have remained remarkably relavant to this day. It highlights that the S language and, by extension R, has been designed for data analysis since its inception.</p>
</div>
<div id="why-tidiness-is-important-for-modeling" class="section level2">
<h2><span class="header-section-number">1.2</span> Why tidiness is important for modeling</h2>
<p>One of the strengths of R is that it encourages developers to create a user-interface that fits their needs. As an example, here are three common methods for creating a scatter plot of two numeric variables residing in a data frame called <code>plot_data</code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">plot</span>(plot_data<span class="op">$</span>x, plot_data<span class="op">$</span>y)</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="kw">library</span>(lattice)</a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="kw">xyplot</span>(y <span class="op">~</span><span class="st"> </span>x, <span class="dt">data =</span> plot_data)</a>
<a class="sourceLine" id="cb17-5" data-line-number="5"></a>
<a class="sourceLine" id="cb17-6" data-line-number="6"><span class="kw">library</span>(ggplot2)</a>
<a class="sourceLine" id="cb17-7" data-line-number="7"><span class="kw">ggplot</span>(plot_data, <span class="kw">aes</span>(<span class="dt">x =</span> y, <span class="dt">y =</span> y)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>()</a></code></pre></div>
<p>In this case, separate groups of developers devised distinct interfaces for the same task. Each has advantages and disadvantages.</p>
<p>In comparison, the <em>Python Developer’s Guide</em> espouses the notion that, when approaching a problem:</p>
<blockquote>
<p>“There should be one– and preferably only one –obvious way to do it.”</p>
</blockquote>
<p>The advantage of R’s diversity of interfaces is that it it can evolve over time and fit different types of needs for different users.</p>
<p>Unfortunately, some of the syntactical diversity is due to a focus on the developer’s needs instead of the needs of the end-user. For example, one issue with some existing methods in base R is that the manner in which some data are stored may not be the most useful. For example, in Section <a href="#r-review"><strong>??</strong></a> the results of linear model were saved:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb18-1" data-line-number="1">main_effect_fit</a></code></pre></div>
<pre><code>## 
## Call:
## lm(formula = rate ~ temp + species, data = crickets)
## 
## Coefficients:
##      (Intercept)              temp  speciesO. niveus  
##           -7.211             3.603           -10.065</code></pre>
<p>The <code>summary()</code> method was used to print the results of the model fit, including a table with parameter values, their uncertainty estimates, and p-values. These particular results can also be saved:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb20-1" data-line-number="1">model_res &lt;-<span class="st"> </span><span class="kw">summary</span>(main_effect_fit)</a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="co"># The model coefficient table is accessible via the `coef`</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="co"># method.</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4">param_est &lt;-<span class="st"> </span><span class="kw">coef</span>(model_res)</a>
<a class="sourceLine" id="cb20-5" data-line-number="5"><span class="kw">class</span>(param_est)</a></code></pre></div>
<pre><code>## [1] &quot;matrix&quot;</code></pre>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb22-1" data-line-number="1">param_est</a></code></pre></div>
<pre><code>##                    Estimate Std. Error    t value     Pr(&gt;|t|)
## (Intercept)       -7.210906 2.55093776  -2.826767 8.582361e-03
## temp               3.602753 0.09728809  37.031799 2.487732e-25
## speciesO. niveus -10.065291 0.73526224 -13.689390 6.271533e-14</code></pre>
<p>There are a few things to notice about this result. First, the object is a numeric matrix. This data structure was mostly likely chosen since all of the calculated results are numeric and a matrix object is stored more efficiently than a data frame. This choice was probably made in the late 1970’s when the level of computational efficiency was critical. Second, the non-numeric data (the labels for the coefficients) are contained in the row names. Keeping the parameter labels as row names is very consistent with the conventions in the original S language.</p>
<p>A reasonable course of action would be to create a visualization of the parameters values (perhaps using one of the plotting methods shown above). To do this, it would be sensible to convert the parameter matrix to a data frame. In doing so, a new column could be created with the variable names so that they can be used in the plot. However, note that several of the matrix column names would not be valid R object names (e.g. <code>&quot;Pr(&gt;|t|)&quot;</code>. Another complication is the consistency of the column names. For <code>lm</code> objects, the column for the test statistic is <code>&quot;Pr(&gt;|t|)&quot;</code>. However, for other models, a different test might be used and, as a result, the column name is different (e.g., <code>&quot;Pr(&gt;|z|)&quot;</code>) and the type of test is <em>encoded in the column name</em>.</p>
<p>While these additional data formatting steps are not problematic they are a bit of an inconvenience, especially since they might be different for different types of models. The matrix is not a highly reusable data structure mostly because it must constrains the data to be of a single type (e.g. numeric). Additionally, keeping some data in the dimension names is also problematic since those data must be extracted to be of general use. For these reasons, the tidyverse places a large degree of importance on data frames and <em>tibbles</em>. Tibbles are data frames with a few extra features and, while they can use them, row names are eschewed.</p>
<p>As a solution, the <code>broom</code> package has methods to convert many types of objects to a tidy structure. For example, using the <code>tidy()</code> method on the linear model produces:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">library</span>(tidymodels)  <span class="co"># includes the broom package</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2"><span class="kw">tidy</span>(main_effect_fit)</a></code></pre></div>
<pre><code>## # A tibble: 3 x 5
##   term             estimate std.error statistic  p.value
##   &lt;chr&gt;               &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;
## 1 (Intercept)         -7.21    2.55       -2.83 8.58e- 3
## 2 temp                 3.60    0.0973     37.0  2.49e-25
## 3 speciesO. niveus   -10.1     0.735     -13.7  6.27e-14</code></pre>
<p>The column names are standardized across models and do not contain any additional data (such as the type of statistical test). The data previously contained in the row names are now in a column called <code>terms</code> and so on. One additional principle in the tidymodels ecosystem is that a functions return values should be <strong>predictable, consistent, and unsurprising</strong>.</p>
<p>As another example of <em>unpredictability</em>, another convention in base R is related to missing data. The general rule is that missing data propagate more missing data; the average of a set of values with a missing data point is itself missing and so on. When models make predictions, the vast majority require all of the predictors to have complete values. There are several options based in to R at this point in the form of <code>na.action</code>. This sets the policy for how a function should behave if there are missing values. The two most common policies are <code>na.fail</code> and <code>na.omit</code>. For former produces an error of missing data are involved while the latter removes the missing data prior to the calculations by case-wise deletion. From our previous example:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="co"># Add a missing value to the prediction set</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2">new_values<span class="op">$</span>temp[<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="ot">NA</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3"></a>
<a class="sourceLine" id="cb26-4" data-line-number="4"><span class="co"># The predict method for `lm` defaults to `na.pass`:</span></a>
<a class="sourceLine" id="cb26-5" data-line-number="5"><span class="kw">predict</span>(main_effect_fit, new_values)</a></code></pre></div>
<pre><code>##        1        2        3        4        5        6 
##       NA 50.43314 54.03589 57.63865 61.24140 64.84415</code></pre>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="co"># Alternatively </span></a>
<a class="sourceLine" id="cb28-2" data-line-number="2"><span class="kw">predict</span>(main_effect_fit, new_values, <span class="dt">na.action =</span> na.fail)</a></code></pre></div>
<pre><code>## Error in na.fail.default(structure(list(temp = c(NA, 16L, 17L, 18L, 19L, : missing values in object</code></pre>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">predict</span>(main_effect_fit, new_values, <span class="dt">na.action =</span> na.omit)</a></code></pre></div>
<pre><code>##        2        3        4        5        6 
## 50.43314 54.03589 57.63865 61.24140 64.84415</code></pre>
<p>From a user’s point of view, <code>na.omit()</code> can be problematic. In our example, <code>new_values</code> has 6 rows but only 5 would be returned. To compensate for this, the user would have to determine which row had the missing value and interleave a missing values in the appropriate place if the predictions were merged into <code>new_values</code><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>. While it is rare that a prediction function uses <code>na.omit()</code> as its missing data policy, this does occur. Users who have determined this as the cause of an error in their code find it <em>quite memorable</em>.</p>
<p>Finally, one other potential stumbling block can be inconsistencies between packages. Suppose a modeling project had an outcome with two classes. There are a variety of statistical and machine learning models that can be used. In order to produce class probability estimate for each sample, it is common for a model function to have a corresponding <code>predict()</code>method. However, there is significant heterogeneity in the argument values used by those methods to make class probability predictions. A sampling of these argument values for different models is:</p>
<table>
<thead>
<tr class="header">
<th align="left">Function</th>
<th align="left">Package</th>
<th align="left">Code</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>lda</code></td>
<td align="left"><code>MASS</code></td>
<td align="left"><code>predict(object)</code></td>
</tr>
<tr class="even">
<td align="left"><code>glm</code></td>
<td align="left"><code>stats</code></td>
<td align="left"><code>predict(object, type = &quot;response&quot;)</code></td>
</tr>
<tr class="odd">
<td align="left"><code>gbm</code></td>
<td align="left"><code>gbm</code></td>
<td align="left"><code>predict(object, type = &quot;response&quot;, n.trees)</code></td>
</tr>
<tr class="even">
<td align="left"><code>mda</code></td>
<td align="left"><code>mda</code></td>
<td align="left"><code>predict(object, type = &quot;posterior&quot;)</code></td>
</tr>
<tr class="odd">
<td align="left"><code>rpart</code></td>
<td align="left"><code>rpart</code></td>
<td align="left"><code>predict(object, type = &quot;prob&quot;)</code></td>
</tr>
<tr class="even">
<td align="left">various</td>
<td align="left"><code>RWeka</code></td>
<td align="left"><code>predict(object, type = &quot;probability&quot;)</code></td>
</tr>
<tr class="odd">
<td align="left"><code>logitboost</code></td>
<td align="left"><code>LogitBoost</code></td>
<td align="left"><code>predict(object, type = &quot;raw&quot;, nIter)</code></td>
</tr>
<tr class="even">
<td align="left"><code>pamr.train</code></td>
<td align="left"><code>pamr</code></td>
<td align="left"><code>pamr.predict(object, type = &quot;posterior&quot;)</code></td>
</tr>
</tbody>
</table>
<p>Note that the last example has a custom <em>function</em> to make predictions instead of using the model common <code>predict()</code> interface.</p>
<p>There are a few R packages that provide a unified interface to harmonize these modeling APIs, such as <code>caret</code> and <code>mlr</code>. tidymodels takes a similar approach to unification of the function interface as well as enforcing consistency in the function names and return values (e.g., <code>broom::tidy()</code>).</p>
</div>
<div id="some-additional-tidy-principals-for-modeling." class="section level2">
<h2><span class="header-section-number">1.3</span> Some additional tidy principals for modeling.</h2>
<p>To resolve the usage issues described in the last section, the tidymodels packages have a few additional design goals that complement those of the tidyverse. However, a considerable amount of the tidymodels goals fall under the existing rubric of <em>Design for Humans</em> but for modeling code. Some examples:</p>
<ul>
<li><p>Make argument and function names less <em>jargony</em>. For example, many statistical regularization methods use the greek letter lambda (<span class="math inline">\(\lambda\)</span>) to represent the amount of penalization that is used during parameter estimation. While very specific, the only users who know what this means are those who have read those parts of the technical literature. When naming things, we prefer more self-documenting (and obvious) choices be used. For example, “penalty” is probably a better name than “lambda”.</p></li>
<li><p>R has excellent capabilities for <em>object oriented programming</em> and this should be used in lieu of creating new function names (such as <code>predict_samples()</code>).</p></li>
<li><p><em>Sensible defaults</em> are very important. Whenever possible, functions should have no default for arguments when only when a default is impossible or if you want to force the user to make a choice. The latter should be used sparingly.</p></li>
<li><p>Similarly, argument values whose default <em>can</em> be derived from the data should be. For example, for <code>glm()</code> the <code>family</code> argument could check the type of data in the outcome and, if no <code>family</code> was given, a default could be determined internally.</p></li>
<li><p>Functions should take the <strong>data structures that users have</strong> as opposed to the data structure required by the underlying computational code. For example, a model function’s <em>only</em> interface should not be constrained to matrices. Frequently, users will have non-numeric predictors such as factors.</p></li>
</ul>
<p>Many of these ideas are described in the tidymodels guidelines for model implementation<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a></p>
<p>A few more principles are discussed below.</p>
<div id="be-predictable-consistent-and-unsurprising" class="section level3">
<h3><span class="header-section-number">1.3.1</span> Be predictable, consistent, and unsurprising</h3>
<p>As seen in the previous section, consistency can be lacking between and within R packages. The tidymodels packages work to</p>
<ul>
<li><p>Follow a consistent syntax in new functions.</p></li>
<li><p>Provide a consistent interface for existing functions.</p></li>
<li><p>Enforce consistency of <em>return values</em> of functions.</p></li>
</ul>
<p>The last point is a good idea for functional programming but also to reduce frustrations for users. Previously, it was mentioned that the <code>summary()</code> method for some functions has column names that changed with the type of model (e.g. <code>&quot;Pr(&gt;|t|)&quot;</code>) and the <code>broom</code> package was used to harmonize the results with the <code>tidy()</code> methods.</p>
<p>There are other, more difficult examples, especially as they relate to model predictions. For example, the <code>ranger</code> package is an excellent tool for computing random forest models. However, instead of returning a data frame or vector as input, a specialized object is returned that have multiple values embedded (including the predicted values). This is just one more step for the data analyst to work around in their scripts. As another example, the <code>glmnet</code> package can return at least four different output types for predictions, depending on the model and characteristics of the data:</p>
<table>
<thead>
<tr class="header">
<th>Type of Prediction</th>
<th>Returns a:</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>numeric</td>
<td>numeric matrix</td>
</tr>
<tr class="even">
<td>class</td>
<td><em>character</em> matrix</td>
</tr>
<tr class="odd">
<td>probability (2 classes)</td>
<td>numeric matrix (2nd level only)</td>
</tr>
<tr class="even">
<td>probability (3+ classes)</td>
<td>3D numeric array (all levels)</td>
</tr>
</tbody>
</table>
<p>Additionally, the column names of the results contain coded values that map to vector in the <code>glmnet</code> model object. This excellent statistical method can be discouraging to use in practice because of all of the special cases one might encounter that require additional code to be useful.</p>
<p>The tidymodels packages always return consistent predicted values that follow several rules:</p>
<ul>
<li><p>The results are always a tibble.</p></li>
<li><p>The number of rows in the tibble always match the number of samples being predicted, regardless of missing values.</p></li>
<li><p>The names and formats of the columns are predictable.</p></li>
</ul>
<p>Finally, to help new R packages, the next section describes a tidymodels package called <code>hardhat</code> that enables package authors implement consistent interfaces and return values.</p>
</div>
<div id="encourage-empirical-validation-and-good-methodology." class="section level3">
<h3><span class="header-section-number">1.3.2</span> Encourage empirical validation and good methodology.</h3>
<p>Enable a wider variety of methodologies</p>
<p>Protect users from making objectively poor choices. Examples:</p>
<ul>
<li><em>Information leakage</em> of training set data into evaluation sets.</li>
<li>Analyzing integers as categories</li>
<li>Down-sampling the test set</li>
</ul>
<p>These examples relate directly to the <em>pit of success</em> mentioned earlier.</p>
<p>One aspect of machine learning models that is applicable to the majority model types is the use of a separate set of data to verify how well the model performs. <em>Data splitting</em> usually reserves a set of the available data that is used after the model building activities are finished. These data serve as an unbiased method for evaluating the capabilities of the model. There is an emphasis on such <em>empirical validation</em> in tidymodels is a more robust approach to establish the performance characteristics of the model.</p>
<p>Similarly, tidymodels strongly leverage resampling methods as a way to empirically characterize characteristics of models. Resampling methods, discussed in Chapter <a href="#resampling"><strong>??</strong></a>, is a type of simulation system that can re-evaluate the model under somewhat different scenarios. This enables the model to be characterized in the context of the observed data as opposed to an unobserved theoretical distribution. For example, in linear regression, we commonly assume normality of the model residuals and base confidence intervals and other quantities on this assumption. Using resampling, similar statistical quantities can be computed but using the <em>empirical distribution</em> of the data. While theoretical and empirical distribution can results in very similar results, it helps to have an additional verification of the results based on the <em>data at hand</em>.</p>
</div>
</div>
</div>








<div class="footnotes">
<hr />
<ol start="1">
<li id="fn1"><p>Most model functions implicitly add an intercept column.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>A base R policy called <code>na.exclude()</code> does exactly this.<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p><code>https://tidymodels.github.io/model-implementation-principles</code><a href="#fnref3" class="footnote-back">↩</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>


    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": false,
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/topepo/TMwR-temp/edit/master/%s",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "section"
},
"search": false
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
